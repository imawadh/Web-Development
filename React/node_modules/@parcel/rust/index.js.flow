// @flow
import type {FileCreateInvalidation, SpecifierType, DependencyPriority, EnvironmentContext, JSONObject, SourceLocation, OutputFormat, SourceType} from '@parcel/types';
import type {Diagnostic} from '@parcel/diagnostic';

declare export var init: void | (() => void);

declare export function findAncestorFile(
  filenames: Array<string>,
  from: string,
  root: string,
): string | null;
declare export function findFirstFile(names: Array<string>): string | null;
declare export function findNodeModule(
  module: string,
  from: string,
): string | null;
declare export function hashString(s: string): string;
declare export function hashBuffer(buf: Buffer): string;
declare export function optimizeImage(kind: string, buf: Buffer): Buffer;
declare export function transformHtml(opts: TransformHtmlOpts): TransformHtmlResult;
declare export function packageHtml(opts: PackageHtmlOpts): PackageHtmlResult;
declare export function optimizeHtml(opts: OptimizeHtmlOpts): PackageHtmlResult;
declare export function transformSvg(opts: TransformHtmlOpts): TransformHtmlResult;
declare export function packageSvg(opts: PackageHtmlOpts): PackageHtmlResult;
declare export function optimizeSvg(opts: OptimizeHtmlOpts): PackageHtmlResult;
declare export function svgReact(opts: OptimizeHtmlOpts): PackageHtmlResult;
export interface JsFileSystemOptions {
  readLink: string => string;
  read: string => Buffer;
  kind: string => number;
  includeNodeModules?: boolean | Array<string> | {|[string]: boolean|};
}
export interface FileSystem {
  fs?: JsFileSystemOptions,
  includeNodeModules?: boolean | Array<string> | {|[string]: boolean|};
  conditions?: number,
  moduleDirResolver?: (...args: any[]) => any,
  mode: number,
  entries?: number,
  extensions?: Array<string>,
  packageExports: boolean
}
export interface ResolveOptions {
  filename: string;
  specifierType: string;
  parent: string;
  packageConditions?: Array<string>;
}
export type Resolution =
  | {|type: 'Path', value: string|}
  | {|type: 'Builtin', value: {|scheme: string, module: string|}|}
  | {|type: 'External'|}
  | {|type: 'Empty'|}
  | {|type: 'Global', value: string|};

export interface ResolveResult {
  resolution: Resolution;
  invalidateOnFileChange: Array<string>;
  invalidateOnFileCreate: Array<FileCreateInvalidation>;
  query?: string;
  sideEffects: boolean;
  error: mixed;
  moduleType: number;
}
export interface JsInvalidations {
  invalidateOnFileChange: Array<string>;
  invalidateOnFileCreate: Array<FileCreateInvalidation>;
  invalidateOnStartup: boolean;
}
declare export function transform(opts: any): any;
declare export function transformAsync(opts: any): Promise<any>;
declare export class Hash {
  writeString(s: string): void;
  writeBuffer(b: Buffer): void;
  finish(): string;
}
export interface ResolverOptions {
  fs?: JsFileSystemOptions;
  includeNodeModules?: boolean | Array<string> | {|[string]: boolean|};
  conditions?: number;
  moduleDirResolver?: (...args: any[]) => any;
  mode: number;
  entries?: number;
  extensions?: Array<string>;
}
declare export class Resolver {
  constructor(projectRoot: string, options: ResolverOptions): Resolver;
  resolve(options: ResolveOptions): ResolveResult;
  resolveAsync(options: ResolveOptions): Promise<ResolveResult>;
  getInvalidations(path: string): JsInvalidations;
}

export interface TransformHtmlOpts {
  code: Buffer,
  filePath: string,
  env: RustEnvironment,
  hmr: boolean
}

export interface TransformHtmlResult {
  code: Buffer,
  dependencies: RustDependency[],
  assets: RustAsset[],
  errors: Diagnostic[]
}

export interface RustEnvironment {
  context: EnvironmentContext,
  outputFormat: OutputFormat,
  sourceType: SourceType,
  flags: number,
  sourceMap: ?any,
  loc: ?SourceLocation,
  includeNodeModules: any,
  engines: any
}

export interface RustDependency {
  specifier: string,
  specifierType: SpecifierType,
  flags: number,
  priority: DependencyPriority,
  bundleBehavior: 'none' | 'isolated' | 'inline',
  env: RustEnvironment,
  loc: ?SourceLocation,
  placeholder: ?string,
  resolveFrom: ?string,
  range: ?string
}

export interface RustAsset {
  loc: ?SourceLocation,
  type: string,
  content: Buffer,
  env: RustEnvironment,
  uniqueKey: string,
  flags: number,
  bundleBehavior: 'none' | 'isolated' | 'inline'
}

export interface PackageHtmlOpts {
  code: Buffer,
  bundles: HtmlBundleReference[],
  inlineBundles: {[string]: HtmlInlineBundle},
  importMap: JSONObject
}

export type HtmlBundleReference =
  | {|type: 'StyleSheet', value: {|href: string|}|}
  | {|type: 'Script', value: {|src: string, module: boolean, nomodule: boolean|}|};

export interface HtmlInlineBundle {
  contents: string,
  module: boolean
}

export interface PackageHtmlResult {
  code: Buffer
}

export interface OptimizeHtmlOpts {
  code: Buffer,
  config: any,
}
